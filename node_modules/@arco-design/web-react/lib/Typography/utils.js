"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.measure = void 0;
var React = __importStar(require("react"));
var react_dom_1 = require("react-dom");
var is_1 = require("../_util/is");
var mergedToString_1 = __importDefault(require("../_util/mergedToString"));
function styleToString(style, extraStyle) {
    var styleNames = Array.prototype.slice.apply(style);
    var styleString = styleNames
        .map(function (name) { return name + ": " + style.getPropertyValue(name) + ";"; })
        .join('');
    var extraStyleString = Object.entries(extraStyle)
        .map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        return key + ": " + value + ";";
    })
        .join('');
    return styleString + extraStyleString;
}
function pxToNumber(value) {
    if (!value)
        return 0;
    var match = value.match(/^\d*(\.\d*)?/);
    return match ? Number(match[0]) : 0;
}
var mirrorElement;
function measure(originElement, ellipsisConfig, operations, children, simple) {
    var rows = ellipsisConfig.rows || 1;
    var ellipsisStr = ellipsisConfig.ellipsisStr !== undefined ? ellipsisConfig.ellipsisStr : '...';
    var suffix = ellipsisConfig.suffix !== undefined ? ellipsisConfig.suffix : '';
    if (mirrorElement && originElement.tagName !== mirrorElement.tagName) {
        document.body.removeChild(mirrorElement);
        mirrorElement = undefined;
    }
    if (!mirrorElement) {
        mirrorElement = document.createElement(originElement.tagName);
        document.body.appendChild(mirrorElement);
    }
    var originStyle = window.getComputedStyle(originElement);
    var extraStyle = {
        height: 'auto',
        'min-height': 'auto',
        'max-height': 'auto',
        left: '0',
        top: '-99999999px',
        // top:'100px',
        position: 'fixed',
        'z-index': '-200',
        'text-overflow': 'clip',
        overflow: 'auto',
    };
    if (!(0, is_1.isNumber)(originStyle.width)) {
        var rect = originElement.getBoundingClientRect();
        extraStyle.width = rect.width + "px";
    }
    var styleString = styleToString(originStyle, extraStyle);
    mirrorElement.setAttribute('style', styleString);
    mirrorElement.setAttribute('aria-hidden', 'true');
    (0, react_dom_1.render)(React.createElement("span", null, operations), mirrorElement);
    var operationsChildNodes = Array.prototype.slice.apply(mirrorElement.childNodes[0].cloneNode(true).childNodes);
    var fullText = (0, mergedToString_1.default)(React.Children.toArray(children));
    (0, react_dom_1.unmountComponentAtNode)(mirrorElement);
    mirrorElement.innerHTML = '';
    var ellipsisTextNode = document.createTextNode("" + ellipsisStr + suffix);
    mirrorElement.appendChild(ellipsisTextNode);
    operationsChildNodes.forEach(function (childNode) {
        mirrorElement.appendChild(childNode);
    });
    var textNode = document.createTextNode(fullText);
    mirrorElement.insertBefore(textNode, mirrorElement.firstChild);
    var lineHeight = pxToNumber(originStyle.lineHeight);
    var maxHeight = Math.round(lineHeight * rows + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
    function emptyMirrorElem() {
        mirrorElement.setAttribute('style', 'display: none');
        mirrorElement.innerHTML = '';
    }
    function inRange() {
        return mirrorElement.scrollHeight <= maxHeight;
    }
    if (inRange()) {
        (0, react_dom_1.unmountComponentAtNode)(mirrorElement);
        emptyMirrorElem();
        return { text: fullText, ellipsis: false };
    }
    if (simple) {
        emptyMirrorElem();
        return { ellipsis: true, text: fullText };
    }
    function measureText(textNode, startLoc, endLoc, lastSuccessLoc) {
        if (startLoc === void 0) { startLoc = 0; }
        if (endLoc === void 0) { endLoc = fullText.length; }
        if (lastSuccessLoc === void 0) { lastSuccessLoc = 0; }
        var midLoc = Math.floor((startLoc + endLoc) / 2);
        var currentText = fullText.slice(0, midLoc);
        textNode.textContent = currentText;
        if (startLoc >= endLoc - 1) {
            for (var step = endLoc; step >= startLoc; step -= 1) {
                var currentStepText = fullText.slice(0, step);
                textNode.textContent = currentStepText;
                if (inRange() || !currentStepText) {
                    return;
                }
            }
        }
        if (inRange()) {
            return measureText(textNode, midLoc, endLoc, midLoc);
        }
        return measureText(textNode, startLoc, midLoc, lastSuccessLoc);
    }
    measureText(textNode);
    var ellipsisText = textNode.textContent;
    emptyMirrorElem();
    return {
        text: ellipsisText,
        ellipsis: true,
    };
}
exports.measure = measure;
